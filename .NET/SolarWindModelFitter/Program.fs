module app

open BurstEngine

open Angara
open Angara.Data
open Angara.Statistics
open Angara.Filzbach

open MathNet.Numerics.LinearAlgebra

//tick is 1 minute real time
let timeToTick t =
    int(round(t*60.0))

let max_hole= 20.0
let max_velocity = 1.0

let getWind (predictorsT: Table) v_max v_p d_max d_p = 
    //velocity slope definition is transforemed
    //parameters
    //max_v (0.0 - 1.0) defained as "wind velocity generated by hole `max_hole`"
    //base_v_p (0.0 - 1.0)defined as "max_v * base_v_p = wind velocity generate by hole near zero area"

    let generatePulse (t:float) area =
        let emergence_tick = timeToTick(t)
        let area = if area<0.0 then 0.0 else area
        if area = 0.0 then
            None
        else
            //max area is considered to be ~ 20
            //should give velocity of 1.0
            //thus
            let k = v_max * (1.0 - v_p) / max_hole
            let b = v_max * v_p
            let velocity = k * area + b                    
            #if DEBUG
            assert(k* max_hole + b = v_max)
            assert(k*0.0 + b = v_max*v_p)
            #endif
            let k = d_max * (1.0 - d_p) / max_hole
            let b = d_max * d_p
            let density = k * area + b                    
            #if DEBUG
            assert(k* max_hole + b = d_max)
            assert(k*0.0 + b = d_max*d_p)
            #endif            
            let burst = {
                EmergenceTime=emergence_tick;
                Velocity=velocity;
                Density= density
            }
            Some(burst)
    Table.Map ["ts";"Relative_CH_CorrectSphereArea_j"] generatePulse predictorsT |> Seq.choose (fun b -> b)  |> List.ofSeq

let expandWind wind = //interpolates the bursts linearly, so burst appear every tick
    let interpolate b1 b2 =
        let t1 = b1.EmergenceTime
        let t2 = b2.EmergenceTime
        let steps = t2-t1
        assert(steps >= 1)        
        let v_step = (b2.Velocity-b1.Velocity)/float(steps)
        let d_step = (b2.Density-b1.Density)/float(steps)
        [
            for i=0 to steps do
                yield {
                    EmergenceTime=t1+i
                    Velocity=b1.Velocity + v_step*float(i)
                    Density=b1.Density + d_step*float(i)
                }
        ]
    let rec expand expanded unexpanded =
        match unexpanded with
        |   h1::h2::tail ->
            expand (List.append (interpolate h1 h2) expanded) tail
        |   h1::[] -> h1::expanded
        |   []  -> expanded
    expand [] wind
    

let mutable bestLglk = System.Double.NegativeInfinity

let logLikelihood (predictorsT: Table) (observationsT: Table) (p: Parameters) =                
    //Distance to Earth
    //varies between 0.9832898912 and 1.0167103335 AU. 
    //which is 1.47098074 to 1.52097701 ×10^8 km
    
    //1 model space step is 1.0x10^8m which is approx 10 Earth diameter
    //thus 1 AU is ~ 1500 model space steps

    let D = p.GetValue "D" //distance to Earth
    let Sigma = p.GetValue "Sigma" //observation noise    
    let v_max = p.GetValue "V_max" //wind velocity generated by constant max_hole
    let v_p = p.GetValue "V_p"
    let d_max = p.GetValue "D_max" //wind density generated by constant max_hole
    let d_p = p.GetValue "D_p"
    let d_b = p.GetValue "D_bg" //density of background wind
    let v_b = p.GetValue "V_bg" //velocity of background wind

    let wind = getWind predictorsT v_max v_p d_max d_p |> expandWind    
    
    let data = Table.Map ["ts";"velocity_mean"] (fun (t:float) (v:float) -> (t,v)) observationsT

    let current_lglk p =
        let t,v = p
        let t = timeToTick t
        let world_state = worldState wind t
        let predAtEarth = windAtDistance world_state (int(round(D)))
        let v_avg_Earth,d_avg_Earth = predAtEarth
        let mu = (v_b*d_b+v_avg_Earth*d_avg_Earth)/(d_b+d_avg_Earth)
        if System.Double.IsNaN mu then
            log improbable
        else
            let distribution = Statistics.Normal(mu,Sigma)
            let lglk = log_pdf distribution v
            //printfn "mu:%g\tv:%g\tsigma:%g\tlglk:%g" mu v Sigma lglk
            lglk        
    let res =
        data |> Seq.map current_lglk
             |> Seq.sum         
    if res>bestLglk then
        printfn "\nlglk improvement:%g\tVm:%g\tVp:%g\tDm:%g\tDp:%g\tVbg:%g\tDbg:%g\tSig:%g\tD:%g"
            res v_max v_p d_max d_p v_b d_b Sigma D
        bestLglk <- res
    else
        printf "."
    res
        

[<EntryPoint>]
let main argv =     
    //config
    let doEstimate = true
    let thinnObs = false
    let seed : uint32 ref = ref 0u
    if argv.Length>0
        then System.UInt32.TryParse(argv.[0],seed) |> ignore
    let rng = new MT19937(!seed)


    //action
    printfn "Seed is %d" !seed

    let ch_data = Table.Load @"..\..\..\..\ResultData\CH_features_cleaned_2015.csv"
    let obs = Table.Load @"..\..\..\..\ResultData\ACE_EPAM_SW_2015.csv"    
    
    let mutable counter = 0
    let obs =
        if thinnObs then
            Table.Filter ["t"]  (fun (dummy:float) ->            
            counter <- counter+1
            counter%5=0            
            ) obs
        else obs

    let predictorsT = Table.Filter ["ts"] (fun t -> t > 40.0 ) ch_data
    let observationsT = Table.Filter ["ts"] (fun t -> t > 150.0 && t < 2140.0) obs

    printfn "Predictor values count %d" predictorsT.RowsCount
    printfn "Observation values count %d" observationsT.RowsCount    
    
    let eps = System.Double.Epsilon

    let estimate predictorsT observationsT =
        let parameters = Parameters.Empty
                            .Add("V_max",[|0.8|],eps,1.0,isLog=true,delay=0)
                            .Add("V_p",[|0.5|],eps,1.0,isLog=true,delay=0)
                            .Add("D_max",[|0.8|],eps,1.0,isLog=true,delay=0)
                            .Add("D_p",[|0.5|],eps,1.0,isLog=true,delay=0)
                            .Add("V_bg",[|300.0|],eps,500.0,isLog=true,delay=0)
                            .Add("D_bg",[|0.5|],eps,1.0,isLog=true,delay=0)
                            .Add("D",[|1500.0|],1200.0,1800.0,isLog=false,delay=0)
                            .Add("Sigma",[| 71.4027|],eps, 500.0,isLog=true,delay=0)                            
        Sampler.runmcmc(parameters, logLikelihood predictorsT observationsT, 5000, 1000,rng=rng)
    if doEstimate then
        let res = estimate predictorsT observationsT    
        Sampler.print res
//        let posterior  =
//            res.samples 
//            |> Seq.mapi (fun i {values=sample} -> Column.Create(res.sampler.Parameters.GetName(i),sample))
//            |> Table.OfColumns
//        printfn "done"
        //Table.Save(posterior, sprintf "posterior_%d.csv" !seed)


    else
        ()
        //simulation    
//        let V_b,V_1,V_2,S_0,S_1,S_2,P_w,Sigma,D = 350.0,40.06,27.8,0.18,2.78,1.04,3.76868e+06,70.7075,1.78556e+08
//
//        let (a,b,c) = get2ndPolyCoefs S_0 S_1 S_2 V_b V_1 V_2
//
//        let testWind = getWind predictorsT V_b S_0 a b c P_w
//
//        let time_start = 0.0
//        let time_step = 0.2
//        let time_stop = 500.0
//        let space_step = 0.5e+6
//        let space_start = 0.0 
//        let space_end = 1.5e+8
//
//        let simulation = simulate testWind time_start time_stop time_step space_start space_end space_step
//
//        //Dumping the data to NetCDF using http://research.microsoft.com/en-us/downloads/ccf905f6-34c6-4845-892e-a5715a508fa3/
//        let ds = Microsoft.Research.Science.Data.DataSet.Open("msds:nc?openMode=create&file=simulation.nc")
//        ds.IsAutocommitEnabled <- false
//        let windVar = ds.AddVariable<float>("windDens",[|"x";"t"|])
//        let windSpVar = ds.AddVariable<float>("avgWindSpeed",[|"x";"t"|])
//        let windSpMaxVar = ds.AddVariable<float>("maxWindSpeed",[|"x";"t"|])
//        let timeAxis = ds.AddVariable<float>("t",[|"t"|])
//        let spaceAxis = ds.AddVariable<float>("x",[|"x"|])        
//
//        let timeObsAxis = ds.AddVariable<float>("obs_time",[|"t_obs"|])
//        let obsAxis = ds.AddVariable<float>("obs",[|"t_obs"|])
//        let predAxis = ds.AddVariable<float>("pred",[|"t_obs"|])
//        let predMeanAxis = ds.AddVariable<float>("predMean",[|"t_obs"|])
//
//        let dummy =
//            Table.MapToColumn "pred" ["t";"velocity"]  (fun (t:float) (v:float) ->
//                let mu = V_b + WindAvgAForTime testWind t D
//                let n = Statistics.Normal(mu,Sigma)
//                let pred = Statistics.draw rng n
//                timeObsAxis.Append([|t|]);
//                obsAxis.Append([|v|]);
//                predAxis.Append([|pred|]);
//                predMeanAxis.Append([|mu|]);
//                printfn "%f %f %f %f" t v pred mu
//                pred
//                ) observationsT
//
//        printfn "simulated for %d time moments" (dummy.RowsCount)
//
//        List.iteri (fun i sim_step_data ->
//            let sample_vals,sample_speed,sample_max_speed = sim_step_data
//            let sample_speed_km_s = List.map (fun a -> a + V_b) sample_speed
//            let t = time_start+float(i)*time_step                            
//            windVar.Append(List.toArray sample_vals,"t")
//            windSpVar.Append(List.toArray sample_speed_km_s,"t")
//            windSpMaxVar.Append(List.toArray sample_max_speed,"t")
//            timeAxis.Append([|t|]);
//            )
//            simulation
//        let spaceAxisData = Array.init (int((space_end-space_start)/space_step)) (fun i -> space_start+float(i)*space_step)
//        spaceAxis.Append(spaceAxisData)
//
//        ds.Commit()        
    
    0 // return an integer exit code
